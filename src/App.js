import logo from "./logo.svg";
import "./App.css";

import React, { useRef, useState, useEffect } from "react";
import * as XLSX from "xlsx";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import Navbar from "./Navbar";
import KanjiList from "./KanjiList";
import RandomKanji from "./RandomKanji";
import DailyLearning from "./DailyLearning";

function App() {
  const fileInputRef = useRef();
  const [kanjiData, setKanjiData] = useState([]);

  // L·∫•y d·ªØ li·ªáu t·ª´ localStorage khi kh·ªüi ƒë·ªông app
  useEffect(() => {
    const stored = localStorage.getItem("kanjiData");
    if (stored) {
      setKanjiData(JSON.parse(stored));
    }
  }, []);

  // Helper functions for kanji comparison
  const arraysEqual = (a, b) => {
    if (!Array.isArray(a) || !Array.isArray(b)) return a === b;

    // L·ªçc b·ªè c√°c ph·∫ßn t·ª≠ r·ªóng
    const filterValid = (arr) =>
      arr.filter((item) => item && item.trim() !== "");

    const validA = filterValid(a);
    const validB = filterValid(b);

    if (validA.length !== validB.length) return false;
    return validA.every((val, index) => val === validB[index]);
  };

  const examplesEqual = (a, b) => {
    if (!Array.isArray(a) || !Array.isArray(b)) return false;

    // L·ªçc b·ªè c√°c example r·ªóng ho·∫∑c null
    const filterValidExamples = (examples) => {
      return examples.filter(
        (example) => example && example.text && example.text.trim() !== ""
      );
    };

    const validA = filterValidExamples(a);
    const validB = filterValidExamples(b);

    if (validA.length !== validB.length) return false;

    return validA.every((example, index) => {
      const otherExample = validB[index];
      return (
        example.text === otherExample.text &&
        example.phonetic === otherExample.phonetic
      );
    });
  };

  const compareKanji = (oldKanji, newKanji) => {
    if (!oldKanji) return "new";

    // So s√°nh c√°c thu·ªôc t√≠nh
    const hanvietChanged = !arraysEqual(oldKanji.hanviet, newKanji.hanviet);
    const kunChanged = !arraysEqual(oldKanji.kun, newKanji.kun);
    const onChanged = !arraysEqual(oldKanji.on, newKanji.on);
    const exampleChanged = !examplesEqual(oldKanji.example, newKanji.example);

    if (hanvietChanged || kunChanged || onChanged || exampleChanged) {
      return "updated";
    }
    return "existing";
  };

  const processExcelFile = (data, fileName = "Excel file") => {
    const workbook = XLSX.read(data, { type: "array", cellStyles: true });
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];

    // L·∫•y d·ªØ li·ªáu c≈© t·ª´ localStorage ƒë·ªÉ so s√°nh
    const oldKanjiData = JSON.parse(localStorage.getItem("kanjiData") || "[]");
    const oldKanjiMap = {};
    oldKanjiData.forEach((item) => {
      oldKanjiMap[item.kanji] = item;
    });

    // ƒê·ªçc v·ªõi raw data ƒë·ªÉ l·∫•y phonetic
    const range = XLSX.utils.decode_range(worksheet["!ref"]);
    const result = [];

    for (let R = range.s.r + 1; R <= range.e.r; ++R) {
      const row = [];
      for (let C = range.s.c; C <= range.e.c; ++C) {
        const cellAddress = XLSX.utils.encode_cell({ c: C, r: R });
        const cell = worksheet[cellAddress];
        if (cell) {
          // L·∫•y phonetic text n·∫øu c√≥ v√† extract ch·ªâ n·ªôi dung hiragana
          let phoneticText = null;
          if (cell.r) {
            if (typeof cell.r === "string") {
              // Extract n·ªôi dung trong <rPh><t>...</t></rPh> - h·ªó tr·ª£ xml:space="preserve"
              const rPhMatch = cell.r.match(
                /<rPh[^>]*><t[^>]*>([^<]+)<\/t><\/rPh>/
              );
              if (rPhMatch) {
                // Trim kho·∫£ng tr·∫Øng th·ª´a nh∆∞ng gi·ªØ kho·∫£ng tr·∫Øng gi·ªØa c√°c k√Ω t·ª±
                phoneticText = rPhMatch[1].trim().replace(/\s+/g, "");
              }
            } else if (Array.isArray(cell.r)) {
              // N·∫øu cell.r l√† array, t√¨m trong c√°c ph·∫ßn t·ª≠
              for (let i = 0; i < cell.r.length; i++) {
                const element = cell.r[i];
                if (element && element.rPh && element.rPh.t) {
                  phoneticText = element.rPh.t;
                  break;
                }
              }
            } else if (typeof cell.r === "object") {
              // N·∫øu cell.r l√† object, ki·ªÉm tra c·∫•u tr√∫c
              if (cell.r.rPh && cell.r.rPh.t) {
                phoneticText = cell.r.rPh.t;
              }
            }
          }
          row[C] = {
            text: cell.v || "",
            phonetic: phoneticText,
          };
        } else {
          row[C] = { text: "", phonetic: null };
        }
      }

      if (row.length >= 6) {
        // Ki·ªÉm tra n·∫øu c√≥ kanji (c·ªôt A kh√¥ng tr·ªëng)
        const kanjiText = row[0].text ? String(row[0].text).trim() : "";
        if (kanjiText !== "") {
          // N·∫øu c√≥ kanji tr∆∞·ªõc ƒë√≥ ch∆∞a ƒë∆∞·ª£c ki·ªÉm tra status cu·ªëi c√πng, ki·ªÉm tra b√¢y gi·ªù
          if (result.length > 0) {
            const lastKanji = result[result.length - 1];
            if (lastKanji.needsStatusCheck) {
              const oldKanji = oldKanjiMap[lastKanji.kanji];
              lastKanji.status = compareKanji(oldKanji, lastKanji);
              delete lastKanji.needsStatusCheck;
            }
          }

          // X·ª≠ l√Ω hanviet reading (c·ªôt B) - t√°ch b·∫±ng d·∫•u ph·∫©y n·∫øu c√≥
          const hanvietText = row[1].text || "";
          const hanvietReadings =
            hanvietText.includes("„ÄÅ") || hanvietText.includes(",")
              ? hanvietText
                  .split(/[„ÄÅ,]/)
                  .map((reading) => reading.trim())
                  .filter((reading) => reading !== "")
              : hanvietText.trim() !== ""
              ? [hanvietText.trim()]
              : [];

          // X·ª≠ l√Ω kun reading (c·ªôt C) - t√°ch b·∫±ng d·∫•u ph·∫©y n·∫øu c√≥
          const kunText = row[2].text || "";
          const kunReadings =
            kunText.includes("„ÄÅ") || kunText.includes(",")
              ? kunText
                  .split(/[„ÄÅ,]/)
                  .map((reading) => reading.trim())
                  .filter((reading) => reading !== "")
              : kunText.trim() !== ""
              ? [kunText.trim()]
              : [];

          // X·ª≠ l√Ω on reading (c·ªôt D) - t√°ch b·∫±ng d·∫•u ph·∫©y n·∫øu c√≥
          const onText = row[3].text || "";
          const onReadings =
            onText.includes("„ÄÅ") || onText.includes(",")
              ? onText
                  .split(/[„ÄÅ,]/)
                  .map((reading) => reading.trim())
                  .filter((reading) => reading !== "")
              : onText.trim() !== ""
              ? [onText.trim()]
              : [];

          const newKanjiItem = {
            kanji: kanjiText,
            hanviet: hanvietReadings,
            kun: kunReadings,
            on: onReadings,
            example: [
              {
                text: row[4].text || "",
                phonetic: row[4].phonetic,
              },
              {
                text: row[5].text || "",
                phonetic: row[5].phonetic,
              },
            ],
            needsStatusCheck: true, // ƒê√°nh d·∫•u c·∫ßn ki·ªÉm tra status sau khi th√™m t·∫•t c·∫£ examples
          };

          result.push(newKanjiItem);
        } else {
          // N·∫øu kh√¥ng c√≥ kanji, th√™m example v√†o kanji tr∆∞·ªõc ƒë√≥
          if (result.length > 0 && (row[4].text || row[5].text)) {
            const lastKanji = result[result.length - 1];
            if (row[4].text) {
              lastKanji.example.push({
                text: row[4].text || "",
                phonetic: row[4].phonetic,
              });
            }
            if (row[5].text) {
              lastKanji.example.push({
                text: row[5].text || "",
                phonetic: row[5].phonetic,
              });
            }
          }
        }
      }
    }

    // Ki·ªÉm tra status cho kanji cu·ªëi c√πng
    if (result.length > 0) {
      const lastKanji = result[result.length - 1];
      if (lastKanji.needsStatusCheck) {
        const oldKanji = oldKanjiMap[lastKanji.kanji];
        lastKanji.status = compareKanji(oldKanji, lastKanji);
        delete lastKanji.needsStatusCheck;
      }
    }

    // Th·ªëng k√™
    const stats = {
      new: result.filter((item) => item.status === "new").length,
      updated: result.filter((item) => item.status === "updated").length,
      existing: result.filter((item) => item.status === "existing").length,
      total: result.length,
    };

    setKanjiData(result);
    localStorage.setItem("kanjiData", JSON.stringify(result));

    // Hi·ªÉn th·ªã th·ªëng k√™ chi ti·∫øt
    alert(
      `ƒê√£ ƒë·ªçc ${stats.total} d√≤ng d·ªØ li·ªáu t·ª´ ${fileName}!\n\n` +
        `üìä Th·ªëng k√™:\n` +
        `üÜï Kanji m·ªõi: ${stats.new}\n` +
        `üîÑ Kanji c·∫≠p nh·∫≠t: ${stats.updated}\n` +
        `‚úÖ Kanji kh√¥ng ƒë·ªïi: ${stats.existing}`
    );
  };

  const handleFileChange = (event) => {
    const file = event.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const data = new Uint8Array(e.target.result);
        processExcelFile(data, file.name);
      };
      reader.readAsArrayBuffer(file);
    }

    // Reset gi√° tr·ªã input ƒë·ªÉ cho ph√©p ch·ªçn l·∫°i c√πng file
    event.target.value = "";
  };

  const loadDefaultFile = async () => {
    try {
      const response = await fetch("/KANJI_N3.xlsx");
      if (!response.ok) {
        throw new Error("Kh√¥ng th·ªÉ t·∫£i file m·∫∑c ƒë·ªãnh");
      }

      const arrayBuffer = await response.arrayBuffer();
      const data = new Uint8Array(arrayBuffer);
      processExcelFile(data, "KANJI_N3.xlsx");
    } catch (error) {
      console.error("Error loading default file:", error);
      alert("L·ªói khi t·∫£i file m·∫∑c ƒë·ªãnh: " + error.message);
    }
  };

  return (
    <Router>
      <Navbar />
      <Routes>
        <Route
          path="/"
          element={
            <div className="App">
              <header className="App-header">
                <div style={{ marginTop: "20px" }}>
                  <input
                    type="file"
                    accept=".xlsx,.xls"
                    ref={fileInputRef}
                    style={{ display: "none" }}
                    onChange={handleFileChange}
                  />
                  <div
                    style={{
                      display: "flex",
                      gap: "10px",
                      flexDirection: "column",
                      alignItems: "center",
                    }}
                  >
                    <button
                      onClick={loadDefaultFile}
                      style={{
                        padding: "10px 20px",
                        fontSize: "16px",
                        backgroundColor: "#007bff",
                        color: "white",
                        border: "none",
                        borderRadius: "5px",
                        cursor: "pointer",
                      }}
                    >
                      T·∫£i file m·∫∑c ƒë·ªãnh (KANJI_N3.xlsx)
                    </button>
                    <button
                      onClick={() => fileInputRef.current.click()}
                      style={{
                        padding: "10px 20px",
                        fontSize: "16px",
                        backgroundColor: "#28a745",
                        color: "white",
                        border: "none",
                        borderRadius: "5px",
                        cursor: "pointer",
                      }}
                    >
                      Upload Excel kh√°c
                    </button>
                  </div>
                </div>
              </header>
            </div>
          }
        />
        <Route
          path="/kanji-list"
          element={<KanjiList kanjiData={kanjiData} />}
        />
        <Route
          path="/random-kanji"
          element={<RandomKanji kanjiData={kanjiData} />}
        />
        <Route
          path="/daily-learning"
          element={<DailyLearning kanjiData={kanjiData} />}
        />
      </Routes>
    </Router>
  );
}

export default App;
